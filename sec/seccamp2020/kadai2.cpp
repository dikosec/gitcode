/********************************************************
---整数係数多項式の剰余演算---
法      : B(x)=(x^n)+1
多項式  : 高々 (2*n)-1次の多項式 A(x)
商      :Q(x)
余り    :R(x)

関係式      :A(x)=B(x)Q(x)+R(x)
次数の関係  :degA=degB+degQ
            :degR<degB

**********************************************************/

#include<vector>
#include<iostream>
//  プログラムを見やすくするために　std::は省略しました。
using namespace std;

//  整数係数多項式の剰余演算の法、(x^n)+1
const int n=1024;
//  プログラム中に2*nが何度も出てくるのでNとしました。
//  乗算の処理をより高速なシフト演算を用いました。
const int N=n << 1;

//  Long Division ユークリッド除法 筆算
//  配列を参照渡することで配列のコピーの時間を削減
void polymod(vector<int64_t> &a,vector<int64_t> &res){

    //  商の係数 tmp
    //  今回は商を記録しておく必要がないので一時的に記憶するものとしてtmpとした
    int64_t tmp=0;

    //  ユークリッド除法では多項式の次数が大きいものから計算していくので最大次数2*n-1から1ずつ減らしてみていく
    //  次数の関係は
    //  degA(x)=degB(x)+degQ(x), 0<=degR(x)<degB(x) となり、
    //  degA(x)=2*n-1,degB(x)=n なので　degQ(x)=degA(x)-degB(x)=(2*n-1)-n=n-1
    //  よって商Q(x)の係数はx^0も含めてn個になるので、繰り返す回数はn回
    //  また、法が(x^n)+1に限られているので、x^nの係数１と(x^0)の係数1の場合だけを記述した
    int i=1;
    while(i<=n){

        //  A(x)の係数が0でない最大次数とB(x)の最大次数の係数に注目し、商の係数を計算求める
        tmp=a[N-i];     //  B(x)の最大次数x^nの係数は常に１なのでa[N-i]/1を省略

        //  A(x)の係数配列aを更新していく
        //  B(x)はx^n+1で項が2つなので更新する箇所も2箇所でよい

        //  A(x)の係数が0でない最大次数の係数からx^nの係数とtmpの積を引いて更新
        a[N-i]-=tmp;    //  x^nの係数は１なので1*tmpを省略

        //  A(x)の係数が0でない最大次数からn次したの係数からB(x)のx^0の係数1とtmpの積を引いて更新
        a[N-(i+n)]-=tmp;    //  x^0の係数は１なので1*tmpを省略
        
        ++i;
    }
    res=a;
}

int main(){
    //  割られる多項式の係数配列
    vector<int64_t> a(N);

    //  INPUT 2*n個の係数
    for(int i=0;i<N;++i) { cin >> a[i];}

    //  解答を格納するためのn要素の64bit符号付き整数の配列
    vector<int64_t> res(n);

    //  関数呼び出し *整数係数多項式の剰余演算*
    polymod(a,res);

    //  OUTPUT　n要素
    //  入力受け取りとして使用した配列が最終的に剰余の形になるので
    for(int i=0;i<n;++i){ cout << res[i] << "\n"; }
}